import pandas as pd
import numpy as np

def backtest_orb(data: pd.DataFrame, signals: pd.DataFrame, stop_loss: float = 0.003, take_profit: float = 0.006):
    """
    Backtest the ORB strategy with breakeven trailing stop and target adjustment:
    - When profit reaches 80% of the take-profit distance, stop moves to breakeven,
      and take-profit is raised to +20% overall gain.

    Parameters
    ----------
    data : pandas.DataFrame
        Intraday OHLC data (with DateTime index).
    signals : pandas.DataFrame
        ORB signals generated by generate_orb_signals().
    stop_loss : float
        Fractional stop-loss (e.g., 0.003 = 0.3%).
    take_profit : float
        Fractional take-profit (e.g., 0.006 = 0.6%).
    """
    df = data.copy()
    trades = []

    for _, sig in signals.iterrows():
        entry_time = sig["Datetime"]
        side = sig["Signal"]

        if entry_time not in df.index:
            continue

        entry_price = float(df.loc[entry_time, "Close"])
        after_entry = df.loc[entry_time:].copy()
        exit_price = entry_price
        breakeven_triggered = False
        adjusted_target = None  # New higher take-profit once triggered

        # Walk forward candle by candle
        for i in range(len(after_entry)):
            bar_high = float(after_entry["High"].iloc[i])
            bar_low = float(after_entry["Low"].iloc[i])

            # Calculate unrealized gain
            move = (bar_high - entry_price) / entry_price if side == 1 else (entry_price - bar_low) / entry_price

            # --- Activate breakeven + raise TP at 80% progress ---
            if not breakeven_triggered and move >= 0.8 * take_profit:
                breakeven_triggered = True
                adjusted_target = 0.20  # new total gain target (+20%)

            # --- Long side logic ---
            if side == 1:
                # Breakeven stop logic
                if breakeven_triggered and bar_low <= entry_price:
                    exit_price = entry_price
                    break
                # Adjusted 20% target
                if adjusted_target is not None and (bar_high - entry_price) / entry_price >= adjusted_target:
                    exit_price = entry_price * (1 + adjusted_target)
                    break
                # Regular take-profit / stop-loss
                if adjusted_target is None and (bar_high - entry_price) / entry_price >= take_profit:
                    exit_price = entry_price * (1 + take_profit)
                    break
                elif (bar_low - entry_price) / entry_price <= -stop_loss:
                    exit_price = entry_price * (1 - stop_loss)
                    break

            # --- Short side logic ---
            elif side == -1:
                if breakeven_triggered and bar_high >= entry_price:
                    exit_price = entry_price
                    break
                if adjusted_target is not None and (entry_price - bar_low) / entry_price >= adjusted_target:
                    exit_price = entry_price * (1 - adjusted_target)
                    break
                if adjusted_target is None and (entry_price - bar_low) / entry_price >= take_profit:
                    exit_price = entry_price * (1 - take_profit)
                    break
                elif (entry_price - bar_high) / entry_price <= -stop_loss:
                    exit_price = entry_price * (1 + stop_loss)
                    break

        # Calculate trade return
        ret = (exit_price - entry_price) / entry_price * side
        trades.append(ret)

    # Build results
    results = pd.DataFrame({"Return": trades})
    results["Cumulative"] = (1 + results["Return"]).cumprod()

    # Performance metrics
    sharpe = np.nan
    if results["Return"].std() > 0:
        sharpe = results["Return"].mean() / results["Return"].std() * (252 ** 0.5)
    mdd = (results["Cumulative"].cummax() - results["Cumulative"]).max()

    return results, sharpe, mdd
