import pandas as pd
import numpy as np

def backtest_orb(data: pd.DataFrame, signals: pd.DataFrame, stop_loss: float = 0.003, take_profit: float = 0.006):
    """
    Backtest the ORB strategy with a breakeven trailing stop once
    profit exceeds 60% of the take-profit target.

    Parameters
    ----------
    data : pandas.DataFrame
        Intraday OHLC data (with DateTime index).
    signals : pandas.DataFrame
        ORB signals generated by generate_orb_signals().
    stop_loss : float
        Fractional stop-loss (e.g., 0.003 = 0.3%).
    take_profit : float
        Fractional take-profit (e.g., 0.006 = 0.6%).
    """
    df = data.copy()
    trades = []

    for _, sig in signals.iterrows():
        entry_time = sig["Datetime"]
        side = sig["Signal"]

        # Skip if entry_time not in data
        if entry_time not in df.index:
            continue

        entry_price = float(df.loc[entry_time, "Close"])
        after_entry = df.loc[entry_time:].copy()
        exit_price = entry_price
        breakeven_triggered = False

        # Walk forward candle by candle
        for i in range(len(after_entry)):
            bar_high = float(after_entry["High"].iloc[i])
            bar_low = float(after_entry["Low"].iloc[i])

            # Track unrealized profit relative to entry
            move = (bar_high - entry_price) / entry_price if side == 1 else (entry_price - bar_low) / entry_price

            # --- Activate breakeven stop once profit â‰¥ 60% of take-profit ---
            if not breakeven_triggered and move >= 0.6 * take_profit:
                breakeven_triggered = True

            # --- Long position logic ---
            if side == 1:
                # If breakeven active and price falls to entry, exit flat
                if breakeven_triggered and bar_low <= entry_price:
                    exit_price = entry_price
                    break
                # Regular TP/SL checks
                if (bar_high - entry_price) / entry_price >= take_profit:
                    exit_price = entry_price * (1 + take_profit)
                    break
                elif (bar_low - entry_price) / entry_price <= -stop_loss:
                    exit_price = entry_price * (1 - stop_loss)
                    break

            # --- Short position logic ---
            elif side == -1:
                if breakeven_triggered and bar_high >= entry_price:
                    exit_price = entry_price
                    break
                if (entry_price - bar_low) / entry_price >= take_profit:
                    exit_price = entry_price * (1 - take_profit)
                    break
                elif (entry_price - bar_high) / entry_price <= -stop_loss:
                    exit_price = entry_price * (1 + stop_loss)
                    break

        # Calculate trade return
        ret = (exit_price - entry_price) / entry_price * side
        trades.append(ret)

    # Build results DataFrame
    results = pd.DataFrame({"Return": trades})
    results["Cumulative"] = (1 + results["Return"]).cumprod()

    # Performance metrics
    sharpe = np.nan
    if results["Return"].std() > 0:
        sharpe = results["Return"].mean() / results["Return"].std() * (252 ** 0.5)

    mdd = (results["Cumulative"].cummax() - results["Cumulative"]).max()
    return results, sharpe, mdd
